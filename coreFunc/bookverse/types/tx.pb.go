// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nftstays/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// this line is used by starport scaffolding # proto/tx/message
type MsgSendIbcTransferNftStay struct {
	Sender           string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Port             string `protobuf:"bytes,2,opt,name=port,proto3" json:"port,omitempty"`
	ChannelID        string `protobuf:"bytes,3,opt,name=channelID,proto3" json:"channelID,omitempty"`
	TimeoutTimestamp uint64 `protobuf:"varint,4,opt,name=timeoutTimestamp,proto3" json:"timeoutTimestamp,omitempty"`
	SID              string `protobuf:"bytes,5,opt,name=sID,proto3" json:"sID,omitempty"`
	NftStorageCID    string `protobuf:"bytes,6,opt,name=nftStorageCID,proto3" json:"nftStorageCID,omitempty"`
}

func (m *MsgSendIbcTransferNftStay) Reset()         { *m = MsgSendIbcTransferNftStay{} }
func (m *MsgSendIbcTransferNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgSendIbcTransferNftStay) ProtoMessage()    {}
func (*MsgSendIbcTransferNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{0}
}
func (m *MsgSendIbcTransferNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendIbcTransferNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendIbcTransferNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendIbcTransferNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendIbcTransferNftStay.Merge(m, src)
}
func (m *MsgSendIbcTransferNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendIbcTransferNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendIbcTransferNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendIbcTransferNftStay proto.InternalMessageInfo

func (m *MsgSendIbcTransferNftStay) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgSendIbcTransferNftStay) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *MsgSendIbcTransferNftStay) GetChannelID() string {
	if m != nil {
		return m.ChannelID
	}
	return ""
}

func (m *MsgSendIbcTransferNftStay) GetTimeoutTimestamp() uint64 {
	if m != nil {
		return m.TimeoutTimestamp
	}
	return 0
}

func (m *MsgSendIbcTransferNftStay) GetSID() string {
	if m != nil {
		return m.SID
	}
	return ""
}

func (m *MsgSendIbcTransferNftStay) GetNftStorageCID() string {
	if m != nil {
		return m.NftStorageCID
	}
	return ""
}

type MsgSendIbcTransferNftStayResponse struct {
}

func (m *MsgSendIbcTransferNftStayResponse) Reset()         { *m = MsgSendIbcTransferNftStayResponse{} }
func (m *MsgSendIbcTransferNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendIbcTransferNftStayResponse) ProtoMessage()    {}
func (*MsgSendIbcTransferNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{1}
}
func (m *MsgSendIbcTransferNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendIbcTransferNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendIbcTransferNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendIbcTransferNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendIbcTransferNftStayResponse.Merge(m, src)
}
func (m *MsgSendIbcTransferNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendIbcTransferNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendIbcTransferNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendIbcTransferNftStayResponse proto.InternalMessageInfo

type MsgUnsellNftStay struct {
	Creator  string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MarketId string `protobuf:"bytes,2,opt,name=marketId,proto3" json:"marketId,omitempty"`
	Seller   string `protobuf:"bytes,3,opt,name=seller,proto3" json:"seller,omitempty"`
}

func (m *MsgUnsellNftStay) Reset()         { *m = MsgUnsellNftStay{} }
func (m *MsgUnsellNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgUnsellNftStay) ProtoMessage()    {}
func (*MsgUnsellNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{2}
}
func (m *MsgUnsellNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnsellNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnsellNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnsellNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnsellNftStay.Merge(m, src)
}
func (m *MsgUnsellNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnsellNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnsellNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnsellNftStay proto.InternalMessageInfo

func (m *MsgUnsellNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUnsellNftStay) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *MsgUnsellNftStay) GetSeller() string {
	if m != nil {
		return m.Seller
	}
	return ""
}

type MsgUnsellNftStayResponse struct {
}

func (m *MsgUnsellNftStayResponse) Reset()         { *m = MsgUnsellNftStayResponse{} }
func (m *MsgUnsellNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUnsellNftStayResponse) ProtoMessage()    {}
func (*MsgUnsellNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{3}
}
func (m *MsgUnsellNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnsellNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnsellNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnsellNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnsellNftStayResponse.Merge(m, src)
}
func (m *MsgUnsellNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnsellNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnsellNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnsellNftStayResponse proto.InternalMessageInfo

type MsgClaimNftStay struct {
	Creator  string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MarketId string `protobuf:"bytes,2,opt,name=marketId,proto3" json:"marketId,omitempty"`
	Buyer    string `protobuf:"bytes,3,opt,name=buyer,proto3" json:"buyer,omitempty"`
}

func (m *MsgClaimNftStay) Reset()         { *m = MsgClaimNftStay{} }
func (m *MsgClaimNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgClaimNftStay) ProtoMessage()    {}
func (*MsgClaimNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{4}
}
func (m *MsgClaimNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimNftStay.Merge(m, src)
}
func (m *MsgClaimNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimNftStay proto.InternalMessageInfo

func (m *MsgClaimNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgClaimNftStay) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *MsgClaimNftStay) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

type MsgClaimNftStayResponse struct {
}

func (m *MsgClaimNftStayResponse) Reset()         { *m = MsgClaimNftStayResponse{} }
func (m *MsgClaimNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimNftStayResponse) ProtoMessage()    {}
func (*MsgClaimNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{5}
}
func (m *MsgClaimNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimNftStayResponse.Merge(m, src)
}
func (m *MsgClaimNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimNftStayResponse proto.InternalMessageInfo

type MsgBidNftStay struct {
	Creator  string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MarketId string `protobuf:"bytes,2,opt,name=marketId,proto3" json:"marketId,omitempty"`
	Buyer    string `protobuf:"bytes,3,opt,name=buyer,proto3" json:"buyer,omitempty"`
	Price    int32  `protobuf:"varint,4,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *MsgBidNftStay) Reset()         { *m = MsgBidNftStay{} }
func (m *MsgBidNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgBidNftStay) ProtoMessage()    {}
func (*MsgBidNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{6}
}
func (m *MsgBidNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBidNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBidNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBidNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBidNftStay.Merge(m, src)
}
func (m *MsgBidNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgBidNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBidNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBidNftStay proto.InternalMessageInfo

func (m *MsgBidNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgBidNftStay) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *MsgBidNftStay) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

func (m *MsgBidNftStay) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

type MsgBidNftStayResponse struct {
}

func (m *MsgBidNftStayResponse) Reset()         { *m = MsgBidNftStayResponse{} }
func (m *MsgBidNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBidNftStayResponse) ProtoMessage()    {}
func (*MsgBidNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{7}
}
func (m *MsgBidNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBidNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBidNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBidNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBidNftStayResponse.Merge(m, src)
}
func (m *MsgBidNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBidNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBidNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBidNftStayResponse proto.InternalMessageInfo

type MsgBuyNftStay struct {
	Creator  string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	MarketId string `protobuf:"bytes,2,opt,name=marketId,proto3" json:"marketId,omitempty"`
	Buyer    string `protobuf:"bytes,3,opt,name=buyer,proto3" json:"buyer,omitempty"`
}

func (m *MsgBuyNftStay) Reset()         { *m = MsgBuyNftStay{} }
func (m *MsgBuyNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgBuyNftStay) ProtoMessage()    {}
func (*MsgBuyNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{8}
}
func (m *MsgBuyNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBuyNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBuyNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBuyNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBuyNftStay.Merge(m, src)
}
func (m *MsgBuyNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgBuyNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBuyNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBuyNftStay proto.InternalMessageInfo

func (m *MsgBuyNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgBuyNftStay) GetMarketId() string {
	if m != nil {
		return m.MarketId
	}
	return ""
}

func (m *MsgBuyNftStay) GetBuyer() string {
	if m != nil {
		return m.Buyer
	}
	return ""
}

type MsgBuyNftStayResponse struct {
}

func (m *MsgBuyNftStayResponse) Reset()         { *m = MsgBuyNftStayResponse{} }
func (m *MsgBuyNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBuyNftStayResponse) ProtoMessage()    {}
func (*MsgBuyNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{9}
}
func (m *MsgBuyNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBuyNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBuyNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBuyNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBuyNftStayResponse.Merge(m, src)
}
func (m *MsgBuyNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBuyNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBuyNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBuyNftStayResponse proto.InternalMessageInfo

type MsgSellNftStay struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SID       string `protobuf:"bytes,2,opt,name=sID,proto3" json:"sID,omitempty"`
	Seller    string `protobuf:"bytes,3,opt,name=seller,proto3" json:"seller,omitempty"`
	Price     int32  `protobuf:"varint,4,opt,name=price,proto3" json:"price,omitempty"`
	OnAuction bool   `protobuf:"varint,5,opt,name=onAuction,proto3" json:"onAuction,omitempty"`
	Expired   int32  `protobuf:"varint,6,opt,name=expired,proto3" json:"expired,omitempty"`
}

func (m *MsgSellNftStay) Reset()         { *m = MsgSellNftStay{} }
func (m *MsgSellNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgSellNftStay) ProtoMessage()    {}
func (*MsgSellNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{10}
}
func (m *MsgSellNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSellNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSellNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSellNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSellNftStay.Merge(m, src)
}
func (m *MsgSellNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgSellNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSellNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSellNftStay proto.InternalMessageInfo

func (m *MsgSellNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSellNftStay) GetSID() string {
	if m != nil {
		return m.SID
	}
	return ""
}

func (m *MsgSellNftStay) GetSeller() string {
	if m != nil {
		return m.Seller
	}
	return ""
}

func (m *MsgSellNftStay) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *MsgSellNftStay) GetOnAuction() bool {
	if m != nil {
		return m.OnAuction
	}
	return false
}

func (m *MsgSellNftStay) GetExpired() int32 {
	if m != nil {
		return m.Expired
	}
	return 0
}

type MsgSellNftStayResponse struct {
}

func (m *MsgSellNftStayResponse) Reset()         { *m = MsgSellNftStayResponse{} }
func (m *MsgSellNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSellNftStayResponse) ProtoMessage()    {}
func (*MsgSellNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{11}
}
func (m *MsgSellNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSellNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSellNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSellNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSellNftStayResponse.Merge(m, src)
}
func (m *MsgSellNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSellNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSellNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSellNftStayResponse proto.InternalMessageInfo

type MsgCreateMarket struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SID       string `protobuf:"bytes,2,opt,name=sID,proto3" json:"sID,omitempty"`
	Price     int32  `protobuf:"varint,3,opt,name=price,proto3" json:"price,omitempty"`
	Status    string `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	Seller    string `protobuf:"bytes,5,opt,name=seller,proto3" json:"seller,omitempty"`
	OnAuction bool   `protobuf:"varint,6,opt,name=onAuction,proto3" json:"onAuction,omitempty"`
	Offers    string `protobuf:"bytes,7,opt,name=offers,proto3" json:"offers,omitempty"`
	Expired   int32  `protobuf:"varint,8,opt,name=expired,proto3" json:"expired,omitempty"`
}

func (m *MsgCreateMarket) Reset()         { *m = MsgCreateMarket{} }
func (m *MsgCreateMarket) String() string { return proto.CompactTextString(m) }
func (*MsgCreateMarket) ProtoMessage()    {}
func (*MsgCreateMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{12}
}
func (m *MsgCreateMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateMarket.Merge(m, src)
}
func (m *MsgCreateMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateMarket proto.InternalMessageInfo

func (m *MsgCreateMarket) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateMarket) GetSID() string {
	if m != nil {
		return m.SID
	}
	return ""
}

func (m *MsgCreateMarket) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *MsgCreateMarket) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MsgCreateMarket) GetSeller() string {
	if m != nil {
		return m.Seller
	}
	return ""
}

func (m *MsgCreateMarket) GetOnAuction() bool {
	if m != nil {
		return m.OnAuction
	}
	return false
}

func (m *MsgCreateMarket) GetOffers() string {
	if m != nil {
		return m.Offers
	}
	return ""
}

func (m *MsgCreateMarket) GetExpired() int32 {
	if m != nil {
		return m.Expired
	}
	return 0
}

type MsgCreateMarketResponse struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgCreateMarketResponse) Reset()         { *m = MsgCreateMarketResponse{} }
func (m *MsgCreateMarketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateMarketResponse) ProtoMessage()    {}
func (*MsgCreateMarketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{13}
}
func (m *MsgCreateMarketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateMarketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateMarketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateMarketResponse.Merge(m, src)
}
func (m *MsgCreateMarketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateMarketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateMarketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateMarketResponse proto.InternalMessageInfo

func (m *MsgCreateMarketResponse) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MsgUpdateMarket struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Id        uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	SID       string `protobuf:"bytes,3,opt,name=sID,proto3" json:"sID,omitempty"`
	Price     int32  `protobuf:"varint,4,opt,name=price,proto3" json:"price,omitempty"`
	Status    string `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"`
	Seller    string `protobuf:"bytes,6,opt,name=seller,proto3" json:"seller,omitempty"`
	OnAuction bool   `protobuf:"varint,7,opt,name=onAuction,proto3" json:"onAuction,omitempty"`
	Offers    string `protobuf:"bytes,8,opt,name=offers,proto3" json:"offers,omitempty"`
	Expired   int32  `protobuf:"varint,9,opt,name=expired,proto3" json:"expired,omitempty"`
}

func (m *MsgUpdateMarket) Reset()         { *m = MsgUpdateMarket{} }
func (m *MsgUpdateMarket) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateMarket) ProtoMessage()    {}
func (*MsgUpdateMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{14}
}
func (m *MsgUpdateMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateMarket.Merge(m, src)
}
func (m *MsgUpdateMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateMarket proto.InternalMessageInfo

func (m *MsgUpdateMarket) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateMarket) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MsgUpdateMarket) GetSID() string {
	if m != nil {
		return m.SID
	}
	return ""
}

func (m *MsgUpdateMarket) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *MsgUpdateMarket) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MsgUpdateMarket) GetSeller() string {
	if m != nil {
		return m.Seller
	}
	return ""
}

func (m *MsgUpdateMarket) GetOnAuction() bool {
	if m != nil {
		return m.OnAuction
	}
	return false
}

func (m *MsgUpdateMarket) GetOffers() string {
	if m != nil {
		return m.Offers
	}
	return ""
}

func (m *MsgUpdateMarket) GetExpired() int32 {
	if m != nil {
		return m.Expired
	}
	return 0
}

type MsgUpdateMarketResponse struct {
}

func (m *MsgUpdateMarketResponse) Reset()         { *m = MsgUpdateMarketResponse{} }
func (m *MsgUpdateMarketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateMarketResponse) ProtoMessage()    {}
func (*MsgUpdateMarketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{15}
}
func (m *MsgUpdateMarketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateMarketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateMarketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateMarketResponse.Merge(m, src)
}
func (m *MsgUpdateMarketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateMarketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateMarketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateMarketResponse proto.InternalMessageInfo

type MsgDeleteMarket struct {
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Id      uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgDeleteMarket) Reset()         { *m = MsgDeleteMarket{} }
func (m *MsgDeleteMarket) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteMarket) ProtoMessage()    {}
func (*MsgDeleteMarket) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{16}
}
func (m *MsgDeleteMarket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteMarket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteMarket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteMarket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteMarket.Merge(m, src)
}
func (m *MsgDeleteMarket) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteMarket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteMarket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteMarket proto.InternalMessageInfo

func (m *MsgDeleteMarket) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgDeleteMarket) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MsgDeleteMarketResponse struct {
}

func (m *MsgDeleteMarketResponse) Reset()         { *m = MsgDeleteMarketResponse{} }
func (m *MsgDeleteMarketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteMarketResponse) ProtoMessage()    {}
func (*MsgDeleteMarketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{17}
}
func (m *MsgDeleteMarketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteMarketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteMarketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteMarketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteMarketResponse.Merge(m, src)
}
func (m *MsgDeleteMarketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteMarketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteMarketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteMarketResponse proto.InternalMessageInfo

type MsgTransferNftStay struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Sender    string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	Recipient string `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	SID       string `protobuf:"bytes,4,opt,name=sID,proto3" json:"sID,omitempty"`
	Denom     string `protobuf:"bytes,5,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *MsgTransferNftStay) Reset()         { *m = MsgTransferNftStay{} }
func (m *MsgTransferNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgTransferNftStay) ProtoMessage()    {}
func (*MsgTransferNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{18}
}
func (m *MsgTransferNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferNftStay.Merge(m, src)
}
func (m *MsgTransferNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferNftStay proto.InternalMessageInfo

func (m *MsgTransferNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgTransferNftStay) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgTransferNftStay) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *MsgTransferNftStay) GetSID() string {
	if m != nil {
		return m.SID
	}
	return ""
}

func (m *MsgTransferNftStay) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type MsgTransferNftStayResponse struct {
}

func (m *MsgTransferNftStayResponse) Reset()         { *m = MsgTransferNftStayResponse{} }
func (m *MsgTransferNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferNftStayResponse) ProtoMessage()    {}
func (*MsgTransferNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{19}
}
func (m *MsgTransferNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferNftStayResponse.Merge(m, src)
}
func (m *MsgTransferNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferNftStayResponse proto.InternalMessageInfo

type MsgBurnNftStay struct {
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Sender  string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	SID     string `protobuf:"bytes,3,opt,name=sID,proto3" json:"sID,omitempty"`
	Denom   string `protobuf:"bytes,4,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *MsgBurnNftStay) Reset()         { *m = MsgBurnNftStay{} }
func (m *MsgBurnNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgBurnNftStay) ProtoMessage()    {}
func (*MsgBurnNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{20}
}
func (m *MsgBurnNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnNftStay.Merge(m, src)
}
func (m *MsgBurnNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnNftStay proto.InternalMessageInfo

func (m *MsgBurnNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgBurnNftStay) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgBurnNftStay) GetSID() string {
	if m != nil {
		return m.SID
	}
	return ""
}

func (m *MsgBurnNftStay) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type MsgBurnNftStayResponse struct {
}

func (m *MsgBurnNftStayResponse) Reset()         { *m = MsgBurnNftStayResponse{} }
func (m *MsgBurnNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnNftStayResponse) ProtoMessage()    {}
func (*MsgBurnNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{21}
}
func (m *MsgBurnNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnNftStayResponse.Merge(m, src)
}
func (m *MsgBurnNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnNftStayResponse proto.InternalMessageInfo

type MsgMintNftStay struct {
	Creator     string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Sender      string `protobuf:"bytes,2,opt,name=sender,proto3" json:"sender,omitempty"`
	Recipient   string `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	SID         string `protobuf:"bytes,4,opt,name=sID,proto3" json:"sID,omitempty"`
	Denom       string `protobuf:"bytes,5,opt,name=denom,proto3" json:"denom,omitempty"`
	Name        string `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Description string `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	Image       string `protobuf:"bytes,8,opt,name=image,proto3" json:"image,omitempty"`
	TokenUri    string `protobuf:"bytes,9,opt,name=tokenUri,proto3" json:"tokenUri,omitempty"`
}

func (m *MsgMintNftStay) Reset()         { *m = MsgMintNftStay{} }
func (m *MsgMintNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgMintNftStay) ProtoMessage()    {}
func (*MsgMintNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{22}
}
func (m *MsgMintNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintNftStay.Merge(m, src)
}
func (m *MsgMintNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintNftStay proto.InternalMessageInfo

func (m *MsgMintNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgMintNftStay) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgMintNftStay) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *MsgMintNftStay) GetSID() string {
	if m != nil {
		return m.SID
	}
	return ""
}

func (m *MsgMintNftStay) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgMintNftStay) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgMintNftStay) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgMintNftStay) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MsgMintNftStay) GetTokenUri() string {
	if m != nil {
		return m.TokenUri
	}
	return ""
}

type MsgMintNftStayResponse struct {
}

func (m *MsgMintNftStayResponse) Reset()         { *m = MsgMintNftStayResponse{} }
func (m *MsgMintNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintNftStayResponse) ProtoMessage()    {}
func (*MsgMintNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{23}
}
func (m *MsgMintNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintNftStayResponse.Merge(m, src)
}
func (m *MsgMintNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintNftStayResponse proto.InternalMessageInfo

type MsgCreateNftStay struct {
	Creator     string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SID         string `protobuf:"bytes,2,opt,name=sID,proto3" json:"sID,omitempty"`
	Owner       string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	Name        string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Image       string `protobuf:"bytes,6,opt,name=image,proto3" json:"image,omitempty"`
	TokenUri    string `protobuf:"bytes,7,opt,name=tokenUri,proto3" json:"tokenUri,omitempty"`
}

func (m *MsgCreateNftStay) Reset()         { *m = MsgCreateNftStay{} }
func (m *MsgCreateNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgCreateNftStay) ProtoMessage()    {}
func (*MsgCreateNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{24}
}
func (m *MsgCreateNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateNftStay.Merge(m, src)
}
func (m *MsgCreateNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateNftStay proto.InternalMessageInfo

func (m *MsgCreateNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateNftStay) GetSID() string {
	if m != nil {
		return m.SID
	}
	return ""
}

func (m *MsgCreateNftStay) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgCreateNftStay) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateNftStay) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgCreateNftStay) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MsgCreateNftStay) GetTokenUri() string {
	if m != nil {
		return m.TokenUri
	}
	return ""
}

type MsgCreateNftStayResponse struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgCreateNftStayResponse) Reset()         { *m = MsgCreateNftStayResponse{} }
func (m *MsgCreateNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateNftStayResponse) ProtoMessage()    {}
func (*MsgCreateNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{25}
}
func (m *MsgCreateNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateNftStayResponse.Merge(m, src)
}
func (m *MsgCreateNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateNftStayResponse proto.InternalMessageInfo

func (m *MsgCreateNftStayResponse) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MsgUpdateNftStay struct {
	Creator     string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Id          uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	SID         string `protobuf:"bytes,3,opt,name=sID,proto3" json:"sID,omitempty"`
	Owner       string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
	Name        string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	Image       string `protobuf:"bytes,7,opt,name=image,proto3" json:"image,omitempty"`
	TokenUri    string `protobuf:"bytes,8,opt,name=tokenUri,proto3" json:"tokenUri,omitempty"`
}

func (m *MsgUpdateNftStay) Reset()         { *m = MsgUpdateNftStay{} }
func (m *MsgUpdateNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNftStay) ProtoMessage()    {}
func (*MsgUpdateNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{26}
}
func (m *MsgUpdateNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNftStay.Merge(m, src)
}
func (m *MsgUpdateNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNftStay proto.InternalMessageInfo

func (m *MsgUpdateNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateNftStay) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MsgUpdateNftStay) GetSID() string {
	if m != nil {
		return m.SID
	}
	return ""
}

func (m *MsgUpdateNftStay) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgUpdateNftStay) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgUpdateNftStay) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgUpdateNftStay) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *MsgUpdateNftStay) GetTokenUri() string {
	if m != nil {
		return m.TokenUri
	}
	return ""
}

type MsgUpdateNftStayResponse struct {
}

func (m *MsgUpdateNftStayResponse) Reset()         { *m = MsgUpdateNftStayResponse{} }
func (m *MsgUpdateNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNftStayResponse) ProtoMessage()    {}
func (*MsgUpdateNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{27}
}
func (m *MsgUpdateNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNftStayResponse.Merge(m, src)
}
func (m *MsgUpdateNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNftStayResponse proto.InternalMessageInfo

type MsgDeleteNftStay struct {
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Id      uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgDeleteNftStay) Reset()         { *m = MsgDeleteNftStay{} }
func (m *MsgDeleteNftStay) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteNftStay) ProtoMessage()    {}
func (*MsgDeleteNftStay) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{28}
}
func (m *MsgDeleteNftStay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteNftStay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteNftStay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteNftStay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteNftStay.Merge(m, src)
}
func (m *MsgDeleteNftStay) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteNftStay) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteNftStay.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteNftStay proto.InternalMessageInfo

func (m *MsgDeleteNftStay) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgDeleteNftStay) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type MsgDeleteNftStayResponse struct {
}

func (m *MsgDeleteNftStayResponse) Reset()         { *m = MsgDeleteNftStayResponse{} }
func (m *MsgDeleteNftStayResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeleteNftStayResponse) ProtoMessage()    {}
func (*MsgDeleteNftStayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d951be8c6353e97b, []int{29}
}
func (m *MsgDeleteNftStayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeleteNftStayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeleteNftStayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeleteNftStayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeleteNftStayResponse.Merge(m, src)
}
func (m *MsgDeleteNftStayResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeleteNftStayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeleteNftStayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeleteNftStayResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgSendIbcTransferNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgSendIbcTransferNftStay")
	proto.RegisterType((*MsgSendIbcTransferNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgSendIbcTransferNftStayResponse")
	proto.RegisterType((*MsgUnsellNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgUnsellNftStay")
	proto.RegisterType((*MsgUnsellNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgUnsellNftStayResponse")
	proto.RegisterType((*MsgClaimNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgClaimNftStay")
	proto.RegisterType((*MsgClaimNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgClaimNftStayResponse")
	proto.RegisterType((*MsgBidNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgBidNftStay")
	proto.RegisterType((*MsgBidNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgBidNftStayResponse")
	proto.RegisterType((*MsgBuyNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgBuyNftStay")
	proto.RegisterType((*MsgBuyNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgBuyNftStayResponse")
	proto.RegisterType((*MsgSellNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgSellNftStay")
	proto.RegisterType((*MsgSellNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgSellNftStayResponse")
	proto.RegisterType((*MsgCreateMarket)(nil), "kryptopoo.marketplace.nftstays.MsgCreateMarket")
	proto.RegisterType((*MsgCreateMarketResponse)(nil), "kryptopoo.marketplace.nftstays.MsgCreateMarketResponse")
	proto.RegisterType((*MsgUpdateMarket)(nil), "kryptopoo.marketplace.nftstays.MsgUpdateMarket")
	proto.RegisterType((*MsgUpdateMarketResponse)(nil), "kryptopoo.marketplace.nftstays.MsgUpdateMarketResponse")
	proto.RegisterType((*MsgDeleteMarket)(nil), "kryptopoo.marketplace.nftstays.MsgDeleteMarket")
	proto.RegisterType((*MsgDeleteMarketResponse)(nil), "kryptopoo.marketplace.nftstays.MsgDeleteMarketResponse")
	proto.RegisterType((*MsgTransferNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgTransferNftStay")
	proto.RegisterType((*MsgTransferNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgTransferNftStayResponse")
	proto.RegisterType((*MsgBurnNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgBurnNftStay")
	proto.RegisterType((*MsgBurnNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgBurnNftStayResponse")
	proto.RegisterType((*MsgMintNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgMintNftStay")
	proto.RegisterType((*MsgMintNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgMintNftStayResponse")
	proto.RegisterType((*MsgCreateNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgCreateNftStay")
	proto.RegisterType((*MsgCreateNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgCreateNftStayResponse")
	proto.RegisterType((*MsgUpdateNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgUpdateNftStay")
	proto.RegisterType((*MsgUpdateNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgUpdateNftStayResponse")
	proto.RegisterType((*MsgDeleteNftStay)(nil), "kryptopoo.marketplace.nftstays.MsgDeleteNftStay")
	proto.RegisterType((*MsgDeleteNftStayResponse)(nil), "kryptopoo.marketplace.nftstays.MsgDeleteNftStayResponse")
}

func init() { proto.RegisterFile("nftstays/tx.proto", fileDescriptor_d951be8c6353e97b) }

var fileDescriptor_d951be8c6353e97b = []byte{
	// 1090 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcd, 0x8e, 0x1b, 0x45,
	0x10, 0xce, 0xf8, 0xdf, 0x95, 0xec, 0x66, 0x19, 0x25, 0xce, 0xc4, 0x5a, 0x59, 0x8b, 0xe1, 0x10,
	0x22, 0x61, 0x2f, 0x41, 0xfc, 0x73, 0xc9, 0x66, 0x2f, 0x16, 0x32, 0x07, 0x27, 0x7b, 0x01, 0x21,
	0x31, 0xeb, 0x69, 0x4f, 0x86, 0xf5, 0xf4, 0x0c, 0xdd, 0x6d, 0x61, 0x8b, 0x13, 0x77, 0x0e, 0x9c,
	0x78, 0x00, 0x9e, 0x83, 0x07, 0x00, 0xc1, 0x21, 0x12, 0x17, 0x8e, 0x68, 0xf7, 0x05, 0x78, 0x04,
	0x34, 0xdd, 0x33, 0x3d, 0xdd, 0xde, 0x99, 0xa5, 0x67, 0x51, 0xc4, 0xcd, 0xd5, 0xd3, 0x55, 0x5f,
	0x7d, 0x55, 0xd5, 0x55, 0x25, 0xc3, 0x2b, 0x78, 0xc1, 0x28, 0x73, 0x37, 0x74, 0xcc, 0xd6, 0xa3,
	0x98, 0x44, 0x2c, 0xb2, 0x07, 0x67, 0x64, 0x13, 0xb3, 0x28, 0x8e, 0xa2, 0x51, 0xe8, 0x92, 0x33,
	0xc4, 0xe2, 0xa5, 0x3b, 0x47, 0xa3, 0xec, 0x62, 0xff, 0xae, 0x54, 0x11, 0x9f, 0x85, 0x5a, 0xbf,
	0x27, 0x8f, 0xf1, 0x82, 0x3d, 0x65, 0xee, 0x46, 0x9c, 0x0f, 0x7f, 0xb5, 0xe0, 0xfe, 0x94, 0xfa,
	0x4f, 0x11, 0xf6, 0x26, 0xa7, 0xf3, 0x67, 0xc4, 0xc5, 0x74, 0x81, 0xc8, 0xa7, 0xe2, 0x8e, 0xdd,
	0x83, 0x16, 0x45, 0xd8, 0x43, 0xc4, 0xb1, 0x0e, 0xac, 0x07, 0xdd, 0x59, 0x2a, 0xd9, 0x36, 0x34,
	0xe2, 0x88, 0x30, 0xa7, 0xc6, 0x4f, 0xf9, 0x6f, 0x7b, 0x1f, 0xba, 0xf3, 0xe7, 0x2e, 0xc6, 0x68,
	0x39, 0x39, 0x76, 0xea, 0xfc, 0x43, 0x7e, 0x60, 0x3f, 0x84, 0x3d, 0x16, 0x84, 0x28, 0x5a, 0xb1,
	0x67, 0x41, 0x88, 0x28, 0x73, 0xc3, 0xd8, 0x69, 0x1c, 0x58, 0x0f, 0x1a, 0xb3, 0x4b, 0xe7, 0xf6,
	0x1e, 0xd4, 0xe9, 0xe4, 0xd8, 0x69, 0x72, 0x1b, 0xc9, 0x4f, 0xfb, 0x75, 0xd8, 0xe1, 0x6e, 0x47,
	0xc4, 0xf5, 0xd1, 0x93, 0xc9, 0xb1, 0xd3, 0xe2, 0xdf, 0xf4, 0xc3, 0xe1, 0x6b, 0xf0, 0x6a, 0x29,
	0x95, 0x19, 0xa2, 0x71, 0x84, 0x29, 0x1a, 0x7e, 0x09, 0x7b, 0x53, 0xea, 0x9f, 0x60, 0x8a, 0x96,
	0xcb, 0x8c, 0xa6, 0x03, 0xed, 0x39, 0x41, 0x2e, 0x8b, 0x32, 0x9e, 0x99, 0x68, 0xf7, 0xa1, 0x23,
	0xc2, 0x38, 0xf1, 0x52, 0xb2, 0x52, 0x16, 0xc1, 0x59, 0x2e, 0x11, 0x49, 0xd9, 0xa6, 0xd2, 0xb0,
	0x0f, 0xce, 0x36, 0x82, 0x44, 0xff, 0x02, 0x6e, 0x4f, 0xa9, 0xff, 0x64, 0xe9, 0x06, 0xe1, 0x7f,
	0x03, 0xbf, 0x03, 0xcd, 0xd3, 0xd5, 0x46, 0x62, 0x0b, 0x61, 0x78, 0x1f, 0xee, 0x6d, 0x99, 0x97,
	0xc8, 0x5f, 0xc3, 0xce, 0x94, 0xfa, 0x47, 0x81, 0xf7, 0x12, 0x70, 0x93, 0xd3, 0x98, 0x04, 0x73,
	0xc4, 0x53, 0xda, 0x9c, 0x09, 0x61, 0x78, 0x0f, 0xee, 0x6a, 0x90, 0xd2, 0x97, 0xcf, 0x85, 0x2f,
	0xab, 0xcd, 0xcb, 0x88, 0x41, 0x8a, 0x2a, 0x8d, 0x4b, 0xd4, 0x9f, 0x2c, 0xd8, 0xe5, 0xf5, 0x61,
	0x92, 0xf8, 0xb4, 0x06, 0x6b, 0x79, 0x0d, 0x96, 0xa4, 0xbb, 0x98, 0x7b, 0xf2, 0x1a, 0x22, 0xfc,
	0x78, 0x35, 0x67, 0x41, 0x84, 0x79, 0x25, 0x77, 0x66, 0xf9, 0x41, 0x82, 0x8b, 0xd6, 0x71, 0x40,
	0x90, 0xc7, 0x2b, 0xb9, 0x39, 0xcb, 0xc4, 0xa1, 0x03, 0x3d, 0xdd, 0x47, 0xe9, 0xfe, 0x1f, 0x96,
	0xa8, 0x9d, 0xc4, 0x41, 0x34, 0xe5, 0x31, 0xa8, 0xe4, 0xbf, 0xf4, 0xb3, 0xae, 0xfa, 0x99, 0xb0,
	0x62, 0x2e, 0x5b, 0x51, 0xee, 0x7e, 0xc2, 0x8a, 0x4b, 0x0a, 0xdb, 0xa6, 0xc6, 0x56, 0xe3, 0xd5,
	0xda, 0xe6, 0xd5, 0x83, 0x56, 0xb4, 0x58, 0x20, 0x42, 0x9d, 0xb6, 0xd0, 0x12, 0x92, 0xca, 0xb7,
	0xa3, 0xf3, 0x7d, 0x43, 0x54, 0xac, 0x42, 0x2a, 0x23, 0x6c, 0xef, 0x42, 0x2d, 0xf0, 0x38, 0xaf,
	0xc6, 0xac, 0x16, 0x78, 0xc3, 0x0b, 0x11, 0x80, 0x93, 0xd8, 0x33, 0x09, 0x80, 0xd0, 0xae, 0x65,
	0xda, 0x59, 0x40, 0xea, 0x05, 0x01, 0x69, 0x14, 0x07, 0xa4, 0x59, 0x12, 0x90, 0x56, 0x79, 0x40,
	0xda, 0xe5, 0x01, 0xe9, 0x94, 0x05, 0xa4, 0xab, 0x07, 0x44, 0x3c, 0x61, 0x95, 0xa4, 0xac, 0x80,
	0x8f, 0x38, 0xff, 0x63, 0xb4, 0x44, 0xd5, 0xf9, 0xa7, 0x76, 0x55, 0x65, 0x69, 0xf7, 0x7b, 0x0b,
	0xec, 0x29, 0xf5, 0xb7, 0x9b, 0x7f, 0xb9, 0xed, 0x7c, 0x2c, 0xd4, 0xb4, 0xb1, 0xb0, 0x0f, 0x5d,
	0x82, 0xe6, 0x41, 0x1c, 0x20, 0xcc, 0xb2, 0x11, 0x20, 0x0f, 0xb2, 0x0c, 0x34, 0xb4, 0x0c, 0x78,
	0x08, 0x47, 0x61, 0x1a, 0x6a, 0x21, 0x0c, 0xf7, 0xa1, 0x7f, 0xd9, 0x1b, 0xe9, 0xec, 0x57, 0xfc,
	0x11, 0x1f, 0xad, 0x08, 0xbe, 0xbe, 0x9f, 0x85, 0xb5, 0x20, 0x3c, 0x69, 0xa8, 0x9e, 0x88, 0xc7,
	0xa8, 0x60, 0x49, 0x2f, 0xfe, 0x16, 0xbd, 0x64, 0x1a, 0x60, 0xf6, 0x3f, 0x87, 0x2b, 0x99, 0xc5,
	0xd8, 0x0d, 0x51, 0x5a, 0x96, 0xfc, 0xb7, 0x7d, 0x00, 0x37, 0x3d, 0x44, 0xe7, 0x24, 0x88, 0x65,
	0x59, 0x76, 0x67, 0xea, 0x51, 0x62, 0x2b, 0x08, 0x5d, 0x1f, 0xa5, 0x75, 0x29, 0x84, 0xa4, 0xdb,
	0xb2, 0xe8, 0x0c, 0xe1, 0x13, 0x12, 0xf0, 0xba, 0xec, 0xce, 0xa4, 0x9c, 0x06, 0x43, 0x61, 0x2c,
	0x83, 0xf1, 0xb3, 0xc5, 0x67, 0xaa, 0x78, 0xc4, 0xd7, 0x69, 0xad, 0x77, 0xa0, 0x19, 0x7d, 0x83,
	0xf3, 0x46, 0xce, 0x05, 0x49, 0xac, 0x51, 0x4e, 0xac, 0x79, 0x05, 0xb1, 0x56, 0x19, 0xb1, 0xf6,
	0x16, 0xb1, 0x87, 0x7c, 0x5e, 0x6b, 0xde, 0x97, 0xf6, 0xa0, 0xdf, 0x05, 0x55, 0xf1, 0x3c, 0xff,
	0x9d, 0xaa, 0x51, 0x13, 0x12, 0xd4, 0x1b, 0x45, 0xd4, 0x9b, 0xe5, 0xd4, 0x5b, 0x57, 0x50, 0x6f,
	0x97, 0x51, 0xef, 0x6c, 0x51, 0x4f, 0x57, 0x15, 0x95, 0x8d, 0xcc, 0xea, 0xc7, 0x9c, 0xa9, 0x68,
	0x18, 0x95, 0x99, 0xa6, 0x96, 0x35, 0xed, 0xcc, 0xf2, 0xa3, 0xdf, 0x76, 0xa1, 0x3e, 0xa5, 0xbe,
	0xfd, 0xa3, 0x05, 0xbd, 0x92, 0xc5, 0xf3, 0x83, 0xd1, 0xd5, 0x6b, 0xee, 0xa8, 0x74, 0xd1, 0xeb,
	0x3f, 0xbe, 0xb6, 0xaa, 0xcc, 0xfa, 0xb7, 0xb0, 0xa3, 0x2f, 0x88, 0x87, 0x06, 0x36, 0x35, 0x8d,
	0xfe, 0xfb, 0x55, 0x35, 0x24, 0xf8, 0x1a, 0x6e, 0x69, 0xfb, 0xe1, 0xd8, 0xc0, 0x92, 0xaa, 0xd0,
	0x7f, 0xaf, 0xa2, 0x82, 0x44, 0x26, 0x00, 0xca, 0x7e, 0xf8, 0xa6, 0x81, 0x99, 0xfc, 0x7a, 0xff,
	0x9d, 0x4a, 0xd7, 0x35, 0xcc, 0x7c, 0x0f, 0x34, 0xc2, 0x94, 0xd7, 0xcd, 0x30, 0x2f, 0x2d, 0x82,
	0xf6, 0x0a, 0x6e, 0xaa, 0x4b, 0xe0, 0xc8, 0xa8, 0x60, 0xf2, 0xd4, 0xbe, 0x5b, 0xed, 0xbe, 0x96,
	0x58, 0x75, 0x79, 0x33, 0x4a, 0xac, 0xa2, 0x60, 0x96, 0xd8, 0xa2, 0x4d, 0x6a, 0x0d, 0xb7, 0xb4,
	0xad, 0xc9, 0x04, 0x59, 0x55, 0x30, 0x42, 0x2e, 0x5a, 0x59, 0x12, 0x64, 0x6d, 0x5f, 0x31, 0x41,
	0x56, 0x15, 0x8c, 0x90, 0x8b, 0x96, 0x1a, 0xfb, 0x3b, 0x0b, 0x6e, 0x6f, 0x77, 0x95, 0x47, 0x06,
	0xc6, 0xb6, 0xdb, 0xc9, 0x87, 0xd5, 0x75, 0xd4, 0x42, 0x53, 0x17, 0x95, 0x91, 0x51, 0xb9, 0xca,
	0xfb, 0x46, 0x85, 0x56, 0xb0, 0x9c, 0x24, 0xb0, 0xea, 0x62, 0x62, 0x02, 0xab, 0xdc, 0x37, 0x82,
	0x2d, 0x58, 0x03, 0x92, 0xae, 0xa9, 0xaf, 0x00, 0x87, 0xc6, 0xf5, 0x5a, 0xa5, 0x6b, 0x16, 0x0f,
	0xea, 0xa4, 0x65, 0x6b, 0x43, 0xf9, 0xd0, 0xb8, 0x64, 0x2b, 0xb5, 0xec, 0xa2, 0x51, 0x99, 0x80,
	0xeb, 0x73, 0xf2, 0xd0, 0xb8, 0x6a, 0xab, 0x80, 0x17, 0x4e, 0xd3, 0xa3, 0x4f, 0x7e, 0x39, 0x1f,
	0x58, 0x2f, 0xce, 0x07, 0xd6, 0x5f, 0xe7, 0x03, 0xeb, 0x87, 0x8b, 0xc1, 0x8d, 0x17, 0x17, 0x83,
	0x1b, 0x7f, 0x5e, 0x0c, 0x6e, 0x7c, 0xf6, 0x96, 0x1f, 0xb0, 0xe7, 0xab, 0xd3, 0xd1, 0x3c, 0x0a,
	0xc7, 0xd2, 0xfa, 0x58, 0xb1, 0x3e, 0x5e, 0x8f, 0xf3, 0x3f, 0x98, 0x36, 0x31, 0xa2, 0xa7, 0x2d,
	0xfe, 0xaf, 0xd0, 0xdb, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xf4, 0x15, 0xf2, 0xdb, 0x79, 0x12,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// this line is used by starport scaffolding # proto/tx/rpc
	SendIbcTransferNftStay(ctx context.Context, in *MsgSendIbcTransferNftStay, opts ...grpc.CallOption) (*MsgSendIbcTransferNftStayResponse, error)
	UnsellNftStay(ctx context.Context, in *MsgUnsellNftStay, opts ...grpc.CallOption) (*MsgUnsellNftStayResponse, error)
	ClaimNftStay(ctx context.Context, in *MsgClaimNftStay, opts ...grpc.CallOption) (*MsgClaimNftStayResponse, error)
	BidNftStay(ctx context.Context, in *MsgBidNftStay, opts ...grpc.CallOption) (*MsgBidNftStayResponse, error)
	BuyNftStay(ctx context.Context, in *MsgBuyNftStay, opts ...grpc.CallOption) (*MsgBuyNftStayResponse, error)
	SellNftStay(ctx context.Context, in *MsgSellNftStay, opts ...grpc.CallOption) (*MsgSellNftStayResponse, error)
	CreateMarket(ctx context.Context, in *MsgCreateMarket, opts ...grpc.CallOption) (*MsgCreateMarketResponse, error)
	UpdateMarket(ctx context.Context, in *MsgUpdateMarket, opts ...grpc.CallOption) (*MsgUpdateMarketResponse, error)
	DeleteMarket(ctx context.Context, in *MsgDeleteMarket, opts ...grpc.CallOption) (*MsgDeleteMarketResponse, error)
	TransferNftStay(ctx context.Context, in *MsgTransferNftStay, opts ...grpc.CallOption) (*MsgTransferNftStayResponse, error)
	BurnNftStay(ctx context.Context, in *MsgBurnNftStay, opts ...grpc.CallOption) (*MsgBurnNftStayResponse, error)
	MintNftStay(ctx context.Context, in *MsgMintNftStay, opts ...grpc.CallOption) (*MsgMintNftStayResponse, error)
	CreateNftStay(ctx context.Context, in *MsgCreateNftStay, opts ...grpc.CallOption) (*MsgCreateNftStayResponse, error)
	UpdateNftStay(ctx context.Context, in *MsgUpdateNftStay, opts ...grpc.CallOption) (*MsgUpdateNftStayResponse, error)
	DeleteNftStay(ctx context.Context, in *MsgDeleteNftStay, opts ...grpc.CallOption) (*MsgDeleteNftStayResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) SendIbcTransferNftStay(ctx context.Context, in *MsgSendIbcTransferNftStay, opts ...grpc.CallOption) (*MsgSendIbcTransferNftStayResponse, error) {
	out := new(MsgSendIbcTransferNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/SendIbcTransferNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UnsellNftStay(ctx context.Context, in *MsgUnsellNftStay, opts ...grpc.CallOption) (*MsgUnsellNftStayResponse, error) {
	out := new(MsgUnsellNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/UnsellNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimNftStay(ctx context.Context, in *MsgClaimNftStay, opts ...grpc.CallOption) (*MsgClaimNftStayResponse, error) {
	out := new(MsgClaimNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/ClaimNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BidNftStay(ctx context.Context, in *MsgBidNftStay, opts ...grpc.CallOption) (*MsgBidNftStayResponse, error) {
	out := new(MsgBidNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/BidNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BuyNftStay(ctx context.Context, in *MsgBuyNftStay, opts ...grpc.CallOption) (*MsgBuyNftStayResponse, error) {
	out := new(MsgBuyNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/BuyNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SellNftStay(ctx context.Context, in *MsgSellNftStay, opts ...grpc.CallOption) (*MsgSellNftStayResponse, error) {
	out := new(MsgSellNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/SellNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateMarket(ctx context.Context, in *MsgCreateMarket, opts ...grpc.CallOption) (*MsgCreateMarketResponse, error) {
	out := new(MsgCreateMarketResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/CreateMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateMarket(ctx context.Context, in *MsgUpdateMarket, opts ...grpc.CallOption) (*MsgUpdateMarketResponse, error) {
	out := new(MsgUpdateMarketResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/UpdateMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteMarket(ctx context.Context, in *MsgDeleteMarket, opts ...grpc.CallOption) (*MsgDeleteMarketResponse, error) {
	out := new(MsgDeleteMarketResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/DeleteMarket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferNftStay(ctx context.Context, in *MsgTransferNftStay, opts ...grpc.CallOption) (*MsgTransferNftStayResponse, error) {
	out := new(MsgTransferNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/TransferNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnNftStay(ctx context.Context, in *MsgBurnNftStay, opts ...grpc.CallOption) (*MsgBurnNftStayResponse, error) {
	out := new(MsgBurnNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/BurnNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintNftStay(ctx context.Context, in *MsgMintNftStay, opts ...grpc.CallOption) (*MsgMintNftStayResponse, error) {
	out := new(MsgMintNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/MintNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateNftStay(ctx context.Context, in *MsgCreateNftStay, opts ...grpc.CallOption) (*MsgCreateNftStayResponse, error) {
	out := new(MsgCreateNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/CreateNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateNftStay(ctx context.Context, in *MsgUpdateNftStay, opts ...grpc.CallOption) (*MsgUpdateNftStayResponse, error) {
	out := new(MsgUpdateNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/UpdateNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeleteNftStay(ctx context.Context, in *MsgDeleteNftStay, opts ...grpc.CallOption) (*MsgDeleteNftStayResponse, error) {
	out := new(MsgDeleteNftStayResponse)
	err := c.cc.Invoke(ctx, "/kryptopoo.marketplace.nftstays.Msg/DeleteNftStay", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// this line is used by starport scaffolding # proto/tx/rpc
	SendIbcTransferNftStay(context.Context, *MsgSendIbcTransferNftStay) (*MsgSendIbcTransferNftStayResponse, error)
	UnsellNftStay(context.Context, *MsgUnsellNftStay) (*MsgUnsellNftStayResponse, error)
	ClaimNftStay(context.Context, *MsgClaimNftStay) (*MsgClaimNftStayResponse, error)
	BidNftStay(context.Context, *MsgBidNftStay) (*MsgBidNftStayResponse, error)
	BuyNftStay(context.Context, *MsgBuyNftStay) (*MsgBuyNftStayResponse, error)
	SellNftStay(context.Context, *MsgSellNftStay) (*MsgSellNftStayResponse, error)
	CreateMarket(context.Context, *MsgCreateMarket) (*MsgCreateMarketResponse, error)
	UpdateMarket(context.Context, *MsgUpdateMarket) (*MsgUpdateMarketResponse, error)
	DeleteMarket(context.Context, *MsgDeleteMarket) (*MsgDeleteMarketResponse, error)
	TransferNftStay(context.Context, *MsgTransferNftStay) (*MsgTransferNftStayResponse, error)
	BurnNftStay(context.Context, *MsgBurnNftStay) (*MsgBurnNftStayResponse, error)
	MintNftStay(context.Context, *MsgMintNftStay) (*MsgMintNftStayResponse, error)
	CreateNftStay(context.Context, *MsgCreateNftStay) (*MsgCreateNftStayResponse, error)
	UpdateNftStay(context.Context, *MsgUpdateNftStay) (*MsgUpdateNftStayResponse, error)
	DeleteNftStay(context.Context, *MsgDeleteNftStay) (*MsgDeleteNftStayResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) SendIbcTransferNftStay(ctx context.Context, req *MsgSendIbcTransferNftStay) (*MsgSendIbcTransferNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendIbcTransferNftStay not implemented")
}
func (*UnimplementedMsgServer) UnsellNftStay(ctx context.Context, req *MsgUnsellNftStay) (*MsgUnsellNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnsellNftStay not implemented")
}
func (*UnimplementedMsgServer) ClaimNftStay(ctx context.Context, req *MsgClaimNftStay) (*MsgClaimNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimNftStay not implemented")
}
func (*UnimplementedMsgServer) BidNftStay(ctx context.Context, req *MsgBidNftStay) (*MsgBidNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BidNftStay not implemented")
}
func (*UnimplementedMsgServer) BuyNftStay(ctx context.Context, req *MsgBuyNftStay) (*MsgBuyNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyNftStay not implemented")
}
func (*UnimplementedMsgServer) SellNftStay(ctx context.Context, req *MsgSellNftStay) (*MsgSellNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SellNftStay not implemented")
}
func (*UnimplementedMsgServer) CreateMarket(ctx context.Context, req *MsgCreateMarket) (*MsgCreateMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMarket not implemented")
}
func (*UnimplementedMsgServer) UpdateMarket(ctx context.Context, req *MsgUpdateMarket) (*MsgUpdateMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMarket not implemented")
}
func (*UnimplementedMsgServer) DeleteMarket(ctx context.Context, req *MsgDeleteMarket) (*MsgDeleteMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMarket not implemented")
}
func (*UnimplementedMsgServer) TransferNftStay(ctx context.Context, req *MsgTransferNftStay) (*MsgTransferNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferNftStay not implemented")
}
func (*UnimplementedMsgServer) BurnNftStay(ctx context.Context, req *MsgBurnNftStay) (*MsgBurnNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnNftStay not implemented")
}
func (*UnimplementedMsgServer) MintNftStay(ctx context.Context, req *MsgMintNftStay) (*MsgMintNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintNftStay not implemented")
}
func (*UnimplementedMsgServer) CreateNftStay(ctx context.Context, req *MsgCreateNftStay) (*MsgCreateNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNftStay not implemented")
}
func (*UnimplementedMsgServer) UpdateNftStay(ctx context.Context, req *MsgUpdateNftStay) (*MsgUpdateNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNftStay not implemented")
}
func (*UnimplementedMsgServer) DeleteNftStay(ctx context.Context, req *MsgDeleteNftStay) (*MsgDeleteNftStayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNftStay not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_SendIbcTransferNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendIbcTransferNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SendIbcTransferNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/SendIbcTransferNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SendIbcTransferNftStay(ctx, req.(*MsgSendIbcTransferNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UnsellNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUnsellNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UnsellNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/UnsellNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UnsellNftStay(ctx, req.(*MsgUnsellNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/ClaimNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimNftStay(ctx, req.(*MsgClaimNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BidNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBidNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BidNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/BidNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BidNftStay(ctx, req.(*MsgBidNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BuyNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBuyNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BuyNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/BuyNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BuyNftStay(ctx, req.(*MsgBuyNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SellNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSellNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SellNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/SellNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SellNftStay(ctx, req.(*MsgSellNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/CreateMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateMarket(ctx, req.(*MsgCreateMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/UpdateMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateMarket(ctx, req.(*MsgUpdateMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/DeleteMarket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteMarket(ctx, req.(*MsgDeleteMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/TransferNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferNftStay(ctx, req.(*MsgTransferNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/BurnNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnNftStay(ctx, req.(*MsgBurnNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/MintNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintNftStay(ctx, req.(*MsgMintNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/CreateNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateNftStay(ctx, req.(*MsgCreateNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/UpdateNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateNftStay(ctx, req.(*MsgUpdateNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeleteNftStay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeleteNftStay)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeleteNftStay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kryptopoo.marketplace.nftstays.Msg/DeleteNftStay",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeleteNftStay(ctx, req.(*MsgDeleteNftStay))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kryptopoo.marketplace.nftstays.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendIbcTransferNftStay",
			Handler:    _Msg_SendIbcTransferNftStay_Handler,
		},
		{
			MethodName: "UnsellNftStay",
			Handler:    _Msg_UnsellNftStay_Handler,
		},
		{
			MethodName: "ClaimNftStay",
			Handler:    _Msg_ClaimNftStay_Handler,
		},
		{
			MethodName: "BidNftStay",
			Handler:    _Msg_BidNftStay_Handler,
		},
		{
			MethodName: "BuyNftStay",
			Handler:    _Msg_BuyNftStay_Handler,
		},
		{
			MethodName: "SellNftStay",
			Handler:    _Msg_SellNftStay_Handler,
		},
		{
			MethodName: "CreateMarket",
			Handler:    _Msg_CreateMarket_Handler,
		},
		{
			MethodName: "UpdateMarket",
			Handler:    _Msg_UpdateMarket_Handler,
		},
		{
			MethodName: "DeleteMarket",
			Handler:    _Msg_DeleteMarket_Handler,
		},
		{
			MethodName: "TransferNftStay",
			Handler:    _Msg_TransferNftStay_Handler,
		},
		{
			MethodName: "BurnNftStay",
			Handler:    _Msg_BurnNftStay_Handler,
		},
		{
			MethodName: "MintNftStay",
			Handler:    _Msg_MintNftStay_Handler,
		},
		{
			MethodName: "CreateNftStay",
			Handler:    _Msg_CreateNftStay_Handler,
		},
		{
			MethodName: "UpdateNftStay",
			Handler:    _Msg_UpdateNftStay_Handler,
		},
		{
			MethodName: "DeleteNftStay",
			Handler:    _Msg_DeleteNftStay_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nftstays/tx.proto",
}

func (m *MsgSendIbcTransferNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendIbcTransferNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendIbcTransferNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NftStorageCID) > 0 {
		i -= len(m.NftStorageCID)
		copy(dAtA[i:], m.NftStorageCID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NftStorageCID)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SID) > 0 {
		i -= len(m.SID)
		copy(dAtA[i:], m.SID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SID)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TimeoutTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TimeoutTimestamp))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ChannelID) > 0 {
		i -= len(m.ChannelID)
		copy(dAtA[i:], m.ChannelID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Port) > 0 {
		i -= len(m.Port)
		copy(dAtA[i:], m.Port)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Port)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendIbcTransferNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendIbcTransferNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendIbcTransferNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUnsellNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnsellNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnsellNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Seller) > 0 {
		i -= len(m.Seller)
		copy(dAtA[i:], m.Seller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Seller)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUnsellNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnsellNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnsellNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgClaimNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBidNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBidNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBidNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Price != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBidNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBidNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBidNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBuyNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBuyNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBuyNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Buyer) > 0 {
		i -= len(m.Buyer)
		copy(dAtA[i:], m.Buyer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Buyer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MarketId) > 0 {
		i -= len(m.MarketId)
		copy(dAtA[i:], m.MarketId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MarketId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBuyNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBuyNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBuyNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSellNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSellNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSellNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expired != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Expired))
		i--
		dAtA[i] = 0x30
	}
	if m.OnAuction {
		i--
		if m.OnAuction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Price != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Seller) > 0 {
		i -= len(m.Seller)
		copy(dAtA[i:], m.Seller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Seller)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SID) > 0 {
		i -= len(m.SID)
		copy(dAtA[i:], m.SID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSellNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSellNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSellNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expired != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Expired))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Offers) > 0 {
		i -= len(m.Offers)
		copy(dAtA[i:], m.Offers)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Offers)))
		i--
		dAtA[i] = 0x3a
	}
	if m.OnAuction {
		i--
		if m.OnAuction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.Seller) > 0 {
		i -= len(m.Seller)
		copy(dAtA[i:], m.Seller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Seller)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if m.Price != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SID) > 0 {
		i -= len(m.SID)
		copy(dAtA[i:], m.SID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateMarketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateMarketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Expired != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Expired))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Offers) > 0 {
		i -= len(m.Offers)
		copy(dAtA[i:], m.Offers)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Offers)))
		i--
		dAtA[i] = 0x42
	}
	if m.OnAuction {
		i--
		if m.OnAuction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Seller) > 0 {
		i -= len(m.Seller)
		copy(dAtA[i:], m.Seller)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Seller)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Price != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SID) > 0 {
		i -= len(m.SID)
		copy(dAtA[i:], m.SID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateMarketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateMarketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteMarket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteMarket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteMarket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteMarketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteMarketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteMarketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgTransferNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SID) > 0 {
		i -= len(m.SID)
		copy(dAtA[i:], m.SID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBurnNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SID) > 0 {
		i -= len(m.SID)
		copy(dAtA[i:], m.SID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgMintNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenUri) > 0 {
		i -= len(m.TokenUri)
		copy(dAtA[i:], m.TokenUri)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenUri)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SID) > 0 {
		i -= len(m.SID)
		copy(dAtA[i:], m.SID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenUri) > 0 {
		i -= len(m.TokenUri)
		copy(dAtA[i:], m.TokenUri)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenUri)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SID) > 0 {
		i -= len(m.SID)
		copy(dAtA[i:], m.SID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenUri) > 0 {
		i -= len(m.TokenUri)
		copy(dAtA[i:], m.TokenUri)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenUri)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SID) > 0 {
		i -= len(m.SID)
		copy(dAtA[i:], m.SID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SID)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeleteNftStay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteNftStay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteNftStay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeleteNftStayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteNftStayResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeleteNftStayResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgSendIbcTransferNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TimeoutTimestamp != 0 {
		n += 1 + sovTx(uint64(m.TimeoutTimestamp))
	}
	l = len(m.SID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NftStorageCID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSendIbcTransferNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUnsellNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Seller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUnsellNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgClaimNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBidNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovTx(uint64(m.Price))
	}
	return n
}

func (m *MsgBidNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBuyNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MarketId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Buyer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBuyNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSellNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Seller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovTx(uint64(m.Price))
	}
	if m.OnAuction {
		n += 2
	}
	if m.Expired != 0 {
		n += 1 + sovTx(uint64(m.Expired))
	}
	return n
}

func (m *MsgSellNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovTx(uint64(m.Price))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Seller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OnAuction {
		n += 2
	}
	l = len(m.Offers)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Expired != 0 {
		n += 1 + sovTx(uint64(m.Expired))
	}
	return n
}

func (m *MsgCreateMarketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	return n
}

func (m *MsgUpdateMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	l = len(m.SID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovTx(uint64(m.Price))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Seller)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OnAuction {
		n += 2
	}
	l = len(m.Offers)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Expired != 0 {
		n += 1 + sovTx(uint64(m.Expired))
	}
	return n
}

func (m *MsgUpdateMarketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteMarket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	return n
}

func (m *MsgDeleteMarketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgTransferNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTransferNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBurnNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBurnNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgMintNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenUri)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgMintNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenUri)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	return n
}

func (m *MsgUpdateNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	l = len(m.SID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenUri)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeleteNftStay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	return n
}

func (m *MsgDeleteNftStayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgSendIbcTransferNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendIbcTransferNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendIbcTransferNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutTimestamp", wireType)
			}
			m.TimeoutTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftStorageCID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftStorageCID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendIbcTransferNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendIbcTransferNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendIbcTransferNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnsellNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnsellNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnsellNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnsellNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnsellNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnsellNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBidNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBidNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBidNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBidNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBidNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBidNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBuyNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBuyNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBuyNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buyer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buyer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBuyNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBuyNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBuyNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSellNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSellNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSellNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnAuction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnAuction = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expired", wireType)
			}
			m.Expired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expired |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSellNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSellNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSellNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnAuction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnAuction = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expired", wireType)
			}
			m.Expired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expired |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateMarketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateMarketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seller = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnAuction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnAuction = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offers = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expired", wireType)
			}
			m.Expired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expired |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateMarketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateMarketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteMarket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteMarket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteMarket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteMarketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteMarketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteMarketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteNftStay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteNftStay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteNftStay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteNftStayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteNftStayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteNftStayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
